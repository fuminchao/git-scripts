#!/bin/bash

# GITALL_RECURSIVE_DEPTH
# GITALL_CONCURRENT

CMD_ARGS=$@

[ -z "$GITALL_RECURSIVE_DEPTH" ] && GITALL_RECURSIVE_DEPTH=10
REPO_DIR=()
while read -r
do
    if [ -e "$REPLY/.git" ]; then
        REPO_DIR+=("$REPLY")
    fi
done << EOF
`find . -maxdepth $GITALL_RECURSIVE_DEPTH -type d | sort -u`
EOF
REPO_DIR_CNT=${#REPO_DIR[@]}


# create seqfile in TMPDIR
# trap TERMINATE to cleanup
[ -z "$TMPDIR" ] && TMPDIR=/tmp
SEQ_FILE=$TMPDIR/`basename $0`.$$.$RANDOM
echo > $SEQ_FILE
cleanup()
{
    rm -rf $SEQ_FILE
    exit 0
}
trap cleanup SIGKILL SIGINT SIGTERM


export COLOR_LIGHT_RED='\e[1;31m'
export COLOR_LIGHT_GREEN='\e[1;32m'
export COLOR_BLUE='\e[0;34m'
export COLOR_LIGHT_BLUE='\e[1;34m'
export COLOR_YELLOW='\e[1;33m'
export COLOR_LIGHT_PURPLE='\e[1;35m'
export COLOR_NC='\e[0m'

PID_POOL=()
[ -z "$GITALL_CONCURRENT" ] && GITALL_CONCURRENT=5
for i in `seq ${REPO_DIR_CNT}`
do
    if [ ${#PID_POOL[@]} -ge $GITALL_CONCURRENT ]; then
        wait ${PID_POOL[@]:0:1}
        PID_POOL=("${PID_POOL[@]:1}")   # Shift
    fi

    (
    cd ${REPO_DIR[i - 1]}

    xi=0000000000$i
    li=${#REPO_DIR_CNT}
    xi=${xi:n-li}
    STD_OUT="$(printf \
        "$COLOR_LIGHT_PURPLE%s$COLOR_NC $COLOR_LIGHT_BLUE%s$COLOR_NC %s $COLOR_LIGHT_BLUE%s$COLOR_NC $COLOR_YELLOW%s$COLOR_NC" \
        "$xi/${#REPO_DIR[@]}" \
        "`pwd`" "<=>" \
        "`git remote --verbose | grep fetch | cut -d ' ' -f1 | cut -f2`" \
        "`git branch | grep -E "^\*" | cut -d ' ' -f2`")\n"

    #sleep `expr $RANDOM % 3`

    CMD_OUT=`$CMD_ARGS`
    if [ ! -z "$CMD_OUT" ]; then
        STD_OUT="$STD_OUT`$CMD_ARGS`\n"
    fi

    while [ "`cat $SEQ_FILE | wc -l | tr -d ' '`" -lt "$i" ]; do true; done

    echo -en "$STD_OUT"
    echo >> $SEQ_FILE
    ) &

    PID_POOL+=($!)  # PID for waiting
done

# Shift and wait all the rest jobs
while [ ${#PID_POOL[@]} -gt 0 ];
do
    wait ${PID_POOL[@]:0:1}
    PID_POOL=("${PID_POOL[@]:1}")   # Shift
done

cleanup
